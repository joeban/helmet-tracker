#!/usr/bin/env node

/**
 * Helmet Data Enrichment Script
 * Fetches detailed product data for helmets with known ASINs
 * Includes images, prices, availability, and more
 */

const fs = require('fs').promises;
const path = require('path');
require('dotenv').config({ path: '.env.local' });

// Import utilities
const { getProductsByASIN } = require('../src/utils/amazonProductAPI');

// File paths
const ASIN_MAP_FILE = path.join(__dirname, '../data/helmet-asin-map.json');
const EXISTING_CACHE = path.join(__dirname, '../src/data/amazonProductCache.ts');
const ENRICHED_DATA_FILE = path.join(__dirname, '../data/enriched-helmet-data.json');
const PROGRESS_FILE = path.join(__dirname, '../data/enrichment-progress.json');

// Configuration
const BATCH_SIZE = 10; // PA-API allows up to 10 items per request
const DELAY_BETWEEN_BATCHES = 2000; // 2 seconds
const MAX_BATCHES_PER_SESSION = 20; // Conservative limit

// Load existing data
async function loadExistingData() {
  const data = {
    asinMap: {},
    existingCache: {},
    enrichedData: {},
    progress: {
      processedASINs: [],
      lastBatchIndex: 0,
      stats: {
        enriched: 0,
        failed: 0,
        total: 0
      }
    }
  };

  // Load ASIN map
  try {
    const asinData = await fs.readFile(ASIN_MAP_FILE, 'utf-8');
    data.asinMap = JSON.parse(asinData);
  } catch (error) {
    console.log('No ASIN map found. Run discover-asins.js first.');
  }

  // Load existing enriched data
  try {
    const enrichedData = await fs.readFile(ENRICHED_DATA_FILE, 'utf-8');
    data.enrichedData = JSON.parse(enrichedData);
  } catch {
    data.enrichedData = {};
  }

  // Load progress
  try {
    const progressData = await fs.readFile(PROGRESS_FILE, 'utf-8');
    data.progress = JSON.parse(progressData);
  } catch {
    // Use default progress
  }

  // Also get our manually collected ASINs from amazonProductCache.ts
  try {
    const cacheContent = await fs.readFile(EXISTING_CACHE, 'utf-8');
    const helmetToAsinMatch = cacheContent.match(/export const HELMET_TO_ASIN[^{]*{([^}]*)}/);
    if (helmetToAsinMatch) {
      const entries = helmetToAsinMatch[1].match(/"([^"]+)":\s*"([^"]+)"/g);
      if (entries) {
        entries.forEach(entry => {
          const [key, asin] = entry.match(/"([^"]+)"/g).map(s => s.replace(/"/g, ''));
          if (key && asin) {
            // Add to ASIN map if not already there
            const normalizedKey = key.replace(/\s+/g, '_');
            if (!data.asinMap[normalizedKey]) {
              data.asinMap[normalizedKey] = {
                asin,
                confidence: 'high',
                source: 'manual'
              };
            }
          }
        });
      }
    }
  } catch (error) {
    console.log('Could not read existing cache:', error.message);
  }

  return data;
}

// Save progress
async function saveProgress(progress) {
  await fs.writeFile(PROGRESS_FILE, JSON.stringify(progress, null, 2));
}

// Save enriched data
async function saveEnrichedData(enrichedData) {
  await fs.writeFile(ENRICHED_DATA_FILE, JSON.stringify(enrichedData, null, 2));

  // Also generate TypeScript file for immediate use
  const tsContent = generateTypeScriptCache(enrichedData);
  const tsFile = path.join(__dirname, '../src/data/enrichedProductData.ts');
  await fs.writeFile(tsFile, tsContent);
}

// Generate TypeScript cache file
function generateTypeScriptCache(enrichedData) {
  const timestamp = new Date().toISOString();

  return `/**
 * Enriched Amazon Product Data
 * Auto-generated by enrich-helmet-data.js
 * Last updated: ${timestamp}
 */

export interface EnrichedProduct {
  asin: string;
  title: string;
  brand?: string;
  imageUrl?: string;
  price?: {
    amount: number;
    currency: string;
    displayAmount: string;
  };
  listPrice?: {
    amount: number;
    currency: string;
    displayAmount: string;
  };
  savings?: {
    amount: number;
    percent: number;
  };
  availability?: {
    message: string;
    inStock: boolean;
    isPrime?: boolean;
  };
  features?: string[];
  detailPageUrl: string;
  lastUpdated: string;
}

export const ENRICHED_PRODUCTS: Record<string, EnrichedProduct> = ${JSON.stringify(enrichedData, null, 2)};

export function getEnrichedProduct(helmetKey: string): EnrichedProduct | undefined {
  return ENRICHED_PRODUCTS[helmetKey];
}

export function getProductByBrandAndName(brand: string, name: string): EnrichedProduct | undefined {
  const key = \`\${brand}_\${name}\`.replace(/\\s+/g, '_').toUpperCase();
  return ENRICHED_PRODUCTS[key];
}
`;
}

// Create batches of ASINs
function createBatches(asinMap, processedASINs) {
  const entries = Object.entries(asinMap)
    .filter(([key]) => !processedASINs.includes(key));

  const batches = [];
  for (let i = 0; i < entries.length; i += BATCH_SIZE) {
    batches.push(entries.slice(i, i + BATCH_SIZE));
  }

  return batches;
}

// Process a batch of ASINs
async function processBatch(batch) {
  const asinList = batch.map(([, data]) => data.asin || data);
  console.log(`  Fetching data for ASINs: ${asinList.join(', ')}`);

  try {
    const products = await getProductsByASIN(asinList);

    const enrichedBatch = {};
    batch.forEach(([helmetKey], index) => {
      const product = products[index];
      if (product) {
        enrichedBatch[helmetKey] = {
          asin: product.asin,
          title: product.title,
          brand: product.brand,
          imageUrl: product.imageUrl,
          price: product.price,
          listPrice: product.listPrice,
          savings: product.savings,
          availability: product.availability,
          features: product.features,
          detailPageUrl: product.detailPageUrl,
          lastUpdated: new Date().toISOString()
        };
        console.log(`  ‚úÖ Enriched: ${helmetKey}`);
      } else {
        console.log(`  ‚ö†Ô∏è No data for: ${helmetKey}`);
      }
    });

    return enrichedBatch;
  } catch (error) {
    console.log(`  ‚ùå Batch error: ${error.message}`);
    throw error;
  }
}

// Main enrichment process
async function enrichHelmetData() {
  console.log('Starting Helmet Data Enrichment');
  console.log('================================\n');

  const { asinMap, enrichedData, progress } = await loadExistingData();

  const totalASINs = Object.keys(asinMap).length;
  if (totalASINs === 0) {
    console.log('‚ùå No ASINs found. Run discover-asins.js first to find ASINs.');
    return;
  }

  console.log(`Total ASINs available: ${totalASINs}`);
  console.log(`Already enriched: ${progress.stats.enriched}`);
  console.log(`Starting from batch: ${progress.lastBatchIndex}\n`);

  const batches = createBatches(asinMap, progress.processedASINs);

  if (batches.length === 0) {
    console.log('‚úÖ All available ASINs have been enriched!');
    return;
  }

  console.log(`Batches to process: ${batches.length}`);
  console.log(`This session will process: ${Math.min(batches.length, MAX_BATCHES_PER_SESSION)} batches\n`);

  let batchCount = 0;
  let rateLimited = false;

  for (let i = progress.lastBatchIndex; i < batches.length; i++) {
    if (batchCount >= MAX_BATCHES_PER_SESSION) {
      console.log('\nüõë Session limit reached. Run again to continue.');
      break;
    }

    const batch = batches[i];
    console.log(`\nBatch ${i + 1}/${batches.length} (${batch.length} items)`);

    try {
      const enrichedBatch = await processBatch(batch);

      // Merge with existing data
      Object.assign(enrichedData, enrichedBatch);

      // Update progress
      batch.forEach(([key]) => {
        if (!progress.processedASINs.includes(key)) {
          progress.processedASINs.push(key);
        }
      });

      progress.stats.enriched += Object.keys(enrichedBatch).length;
      progress.stats.total = progress.processedASINs.length;
      progress.lastBatchIndex = i + 1;
      batchCount++;

      // Save after each batch
      await saveEnrichedData(enrichedData);
      await saveProgress(progress);

      // Rate limiting delay
      if (i < batches.length - 1) {
        console.log(`  Waiting ${DELAY_BETWEEN_BATCHES}ms...`);
        await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_BATCHES));
      }

    } catch (error) {
      if (error.message?.includes('429')) {
        console.log('\nüö® Rate limited! Progress saved. Try again in 1 hour.');
        rateLimited = true;
        break;
      }
      console.log(`  Error processing batch: ${error.message}`);
      progress.stats.failed++;

      // Skip this batch and continue
      progress.lastBatchIndex = i + 1;
      await saveProgress(progress);
    }
  }

  // Final report
  console.log('\n================================');
  console.log('Enrichment Summary');
  console.log('================================');
  console.log(`Processed this session: ${batchCount} batches`);
  console.log(`Total enriched: ${progress.stats.enriched}/${totalASINs}`);
  console.log(`Failed: ${progress.stats.failed}`);
  console.log(`Progress: ${((progress.stats.enriched / totalASINs) * 100).toFixed(1)}%`);

  if (rateLimited) {
    console.log('\n‚è∞ Rate limited. Wait at least 1 hour before running again.');
  } else if (progress.lastBatchIndex < batches.length) {
    console.log('\n‚úÖ Session complete. Run again to continue enrichment.');
  } else {
    console.log('\nüéâ All ASINs enriched successfully!');
    console.log('Generated files:');
    console.log('  - data/enriched-helmet-data.json');
    console.log('  - src/data/enrichedProductData.ts');
  }
}

// Run if executed directly
if (require.main === module) {
  enrichHelmetData().catch(console.error);
}

module.exports = { enrichHelmetData };